# se-lab04
## نام اعضای تیم:
آرش توانگر 98105643 
</br>
پرهام نجفی فاخر 98171194

پیاده سازی پروژه با روش TDD:
برنامه ابتدا با  رعایت کامل الگوهای طراحی استفاده میکند. سپس در هر مرحله، برنامه نوشته شده با رویکردی طراحی تست محور مورد تست قرار گرفته که از اجزای صحیح اجزا اطمینان حاصل گردد.


**الگوی طراحی استراتژی:**

الگوی طراحی استراتژی یک الگوی رفتاری است که به شما امکان می‌دهد تا رفتار یک شیء را در زمان اجرا تغییر دهید. در این برنامه، ما از الگوی طراحی استراتژی برای تغییر روش ارسال بسته استفاده می‌کنیم. ما یک رابط `ShippingStrategy` تعریف کرده‌ایم که دو پیاده‌سازی، `StandardShipping` و `ExpressShipping`، دارد. هر بسته یک استراتژی ارسال دارد که می‌تواند در زمان اجرا تغییر کند. این به ما امکان می‌دهد تا روش محاسبه هزینه ارسال را بر اساس روش ارسال انتخاب شده تغییر دهیم.

**الگوی طراحی وضعیت:**

الگوی طراحی وضعیت یک الگوی رفتاری است که به شما امکان می‌دهد تا وضعیت یک شیء را در زمان اجرا تغییر دهید. در این برنامه، ما از الگوی طراحی وضعیت برای تغییر وضعیت بسته استفاده می‌کنیم. ما یک رابط `PackageState` تعریف کرده‌ایم که دو پیاده‌سازی، `InTransitState` و `DeliveredState`، دارد. هر بسته یک وضعیت دارد که می‌تواند در زمان اجرا تغییر کند. این به ما امکان می‌دهد تا وضعیت بسته را بر اساس وضعیت ارسال تغییر دهیم.

# پرسش ها
## سوال 1
1. **الگوهای ایجادی (Creational Patterns)**: این الگوها روش‌های نمونه‌سازی (instantiation mechanisms) ارائه می‌کنند و ساخت آبجکت‌ها را به روشی مناسب شرایط ساده‌تر می‌کنند. الگوهای ایجادی به جای اینکه مستقیما از آبجکت‌ها نمونه‌سازی (instantiate) کنید، برای شما آبجکت می‌سازند.
2. **الگوهای ساختاری (Structural Patterns)**: این الگوها به برقراری روابط مناسب بین شیء‌ها کمک می‌کنند. آن‌ها نحوه ترکیب شیء‌ها و کلاس‌ها را برای ایجاد ساختارهای بزرگتر مشخص می‌کنند.
3. **الگوهای رفتاری (Behavioral Patterns)**: این الگوها روابط و تعاملات بین شیء‌ها را مدیریت می‌کنند و مسئولیت‌های آن‌ها را تعیین می‌کنند.

## سوال 2
برنامه‌ای که نوشته شده است، از دسته الگوهای رفتاری یا Behavioral Patterns است. الگوهای رفتاری به تعامل بین شیء‌ها و توزیع مسئولیت‌ها بین آن‌ها می‌پردازند. در این برنامه، ما از دو الگوی رفتاری استفاده کردیم: الگوی طراحی استراتژی و الگوی طراحی وضعیت. الگوی طراحی استراتژی به ما امکان می‌دهد تا رفتار یک شیء را در زمان اجرا تغییر دهیم و الگوی طراحی وضعیت به ما امکان می‌دهد تا وضعیت یک شیء را در زمان اجرا تغییر دهیم.

## سوال 3
برای این مورد، الگوی طراحی Singleton مناسب به نظر می‌رسد. الگوی Singleton یک الگوی ساختاری است که زمانی استفاده می‌شود که بخواهیم اطمینان حاصل کنیم که یک کلاس فقط یک نمونه داشته باشد و یک نقطه دسترسی عمومی برای دسترسی به آن فراهم کنیم.

در این مورد، ما می‌خواهیم تضمین کنیم که فقط یک بسته در هر زمان وجود دارد، بنابراین الگوی Singleton مناسب به نظر می‌رسد.

برای پیاده‌سازی الگوی Singleton در جاوا، می‌توانیم از روش زیر استفاده کنیم:

```java
public class Package {
    private static Package instance;
    private PackageState state;
    private ShippingStrategy strategy;
    private double weight;

    private Package(double weight) {
        this.weight = weight;
        this.state = new InTransitState();
        this.strategy = new StandardShipping();
    }

    public static Package getInstance(double weight) {
        if (instance == null) {
            instance = new Package(weight);
        }
        return instance;
    }

    // rest of the code...
}
```

در این کد، ما یک متغیر استاتیک `instance` از کلاس `Package` داریم که نمونه یکتای این کلاس را نگه می‌دارد. ما همچنین یک متد استاتیک `getInstance` داریم که این نمونه را برمی‌گرداند. اگر نمونه هنوز ایجاد نشده باشد، این متد یک نمونه جدید ایجاد می‌کند.

با استفاده از این روش، ما می‌توانیم تضمین کنیم که فقط یک نمونه از کلاس `Package` در هر زمان وجود دارد، که دقیقا همان چیزی است که ما می‌خواهیم.

## سوال 4

الگوی Singleton در اصول SOLID به شرح زیر عمل می‌کند:

1. **Single Responsibility Principle (SRP)**: الگوی Singleton این اصل را نقض می‌کند. این الگو دو مسئولیت دارد: اطمینان از اینکه تنها یک نمونه از کلاس ساخته شود و ایجاد دسترسی سراسری به آن¹.

2. **Open-Closed Principle (OCP)**: الگوی Singleton این اصل را رعایت می‌کند. کلاس Singleton برای توسعه باز است (می‌توانید آن را به کلاس‌های فرزندی تبدیل کنید) اما برای تغییر بسته است (می‌توانید رفتار آن را تغییر دهید بدون اینکه کد موجود را تغییر دهید).

3. **Liskov Substitution Principle (LSP)**: این اصل در Singleton کمتر مطرح است زیرا Singleton معمولاً نمی‌تواند به درستی از کلاس‌های دیگر به ارث برده شود.

4. **Interface Segregation Principle (ISP)**: این اصل در Singleton کمتر مطرح است زیرا Singleton معمولاً یک رابط ساده دارد و مشتریان نیازی به پیاده‌سازی رابط‌هایی که استفاده نمی‌کنند، ندارند.

5. **Dependency Inversion Principle (DIP)**: الگوی Singleton می‌تواند این اصل را رعایت کند. کلاس‌هایی که از Singleton استفاده می‌کنند، می‌توانند به یک رابط (که توسط Singleton پیاده‌سازی شده است) وابسته باشند، نه یک جزئیات پیاده‌سازی خاص.

